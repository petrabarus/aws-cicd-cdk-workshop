[
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/1-setting-up-environment.html",
	"title": "Setting Up Environment",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Setting Up Environment In this chapter you will set up environment by creating a new AWS Cloud9 Development Environment and make sure the environment is suitable for our development. AWS Cloud9 is a cloud-based integrated development environment (IDE) that lets you write, run, and debug your code with just a browser. It includes a code editor, debugger, and terminal. Cloud9 comes prepackaged with essential tools for popular programming languages, including JavaScript, Python, PHP, and more, so you don’t need to install files or configure your development machine to start new projects.\nClick the orange arrow on the right hand side to continue to next step.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/3-cleaning-up/1-cleaning-cdk-resources.html",
	"title": "1. Cleaning Provisioned Resources",
	"tags": [],
	"description": "",
	"content": "In this part you will remove all resources that provisioned by AWS CDK.\nSTEP 1 In the terminal execute the command below. This will remove the stack that you created previously.\ncdk destroy Input y when prompted \u0026ldquo;Are you sure you want to delete: MyappStack (y/n)?\u0026rdquo;.\nThe process will take a while.\nSTEP 2 Execute the command below to delete the CDK assets resources.\naws s3 rm --recursive s3://$(aws s3 ls | grep cdktoolkit | head -n 1 | cut -d\u0026#39; \u0026#39; -f3) aws cloudformation delete-stack --stack-name CDKToolkit Click the orange arrow on the right hand side to continue.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/2-workshop/1-creating-new-cdk-application.html",
	"title": "1. Creating new CDK Application",
	"tags": [],
	"description": "",
	"content": "In this part you are going to create a new CDK application.\nSTEP 1 Create a new directory for the application.\nmkdir myapp \u0026amp;\u0026amp; cd myapp STEP 2 initiate a new CDK application by executing command below.\ncdk init app --language typescript You will notice new files and directory in the myapp directory.\nSTEP 3 Create a new terminal by clicking on the green cross, and click New Terminal.\nSTEP 4 In the new terminal, go to our app by executing this command.\ncd myapp STEP 5 You need to compile your Typescript code to Javascript everytime you create or update a Typescript file. To do that execute the code below.\nnpm run watch If you by any chance close this terminal, you need to redo the step in new terminal.\nSTEP 6 Go back to our previous terminal.\nSTEP 7 Now you may want to see the CloudFormation template that will be generated by the CDK code. Execute the command below.\ncdk synth The command will output YAML text that contains CloudFormation template.\nSTEP 8 Before you deploy the CDK code to our AWS account, you need to provision CDK resources that is required by CDK to store assets. This can charge small cost to your AWS account, you are going to delete the resources in the last part of the workshop.\nExecute command below to bootstrap.\ncdk bootstrap It will output something a bit similar to text below.\n⏳ Bootstrapping environment aws://1234567890/us-east-1... ✅ Environment aws://1234567890/us-east-1 bootstrapped (no changes). STEP 9 To deploy the CDK application, execute command below.\ncdk deploy This will output text a bit similar to text below.\nStack ARN: arn:aws:cloudformation:us-east-1:1234567890:stack/MyappStack/aaaaaaaa-bbbb-cccc-dddd-ffffffffffff To check whether the stack is deployed, open CloudFormation console and see if a new stack MyappStack is deployed.\nNOTE If in the next cdk deploy, your IDE shows insufficient space, try deleting the content of the cdk.out directory by executing the following command in the project root directory.\nrm -rf cdk.out/* Click the orange arrow on the right hand side to continue to next step.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/1-setting-up-environment/1-setting-up-cloud9.html",
	"title": "1. Setting Up AWS Cloud9",
	"tags": [],
	"description": "",
	"content": "Now you are going to provision your AWS Cloud9 Integrated Development Environment.\nSTEP 1 Go to AWS Cloud9 Console.\nSTEP 2 Click Create environment\nSTEP 3 Put \u0026ldquo;CICD-CDK-Workshop\u0026rdquo; or any name you like in the Name field. You can leave the description empty. Click Next step to proceed.\nSTEP 4 In the Environment settings, choose below configuration\n \u0026ldquo;Create a new EC2 instance for environment (direct access)\u0026rdquo; in the Environment type \u0026ldquo;t2.micro (1 GiB RAM + 1 vCPU)\u0026rdquo; in the Instance type \u0026ldquo;Amazon Linux 2\u0026rdquo; in the Platform  Leave everything else as default. Click Next step to proceed.\nSTEP 5 In the step Review, make sure the configurations are correct. Click Create environment to proceed.\nSTEP 6 Please wait for a couple of minutes while an instance of AWS Cloud9 is being set up.\nFINAL Now the new AWS Cloud9 IDE is ready to use.\nClick the orange arrow on the right hand side to continue to next step.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/2-workshop.html",
	"title": "Workshop",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Building CI/CD Pipeline using AWS CDK Now you are going to start working on building CI/CD Pipeline using AWS CDK.\nClick the orange arrow on the right hand side to continue to start the workshop.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/2-workshop/2-creating-code-commit-repository-copy.html",
	"title": "2. Creating CodeCommit Repository",
	"tags": [],
	"description": "",
	"content": "In this part, you are going to create an AWS CodeCommit repository. AWS CodeCommit is a fully-managed source control service that hosts secure Git-based repositories. It makes it easy for teams to collaborate on code in a secure and highly scalable ecosystem.\nProvision AWS CodeCommit Repository STEP 1 Install AWS CodeCommit constructs for CDK by executing command below in our project directory.\nnpm i @aws-cdk/aws-codecommit STEP 2 You are going to provision a new CodeCommit repository using CDK. Overwrite file lib/myapp-stack.ts with the follow code.\nimport * as cdk from \u0026#39;@aws-cdk/core\u0026#39;; import * as codecommit from \u0026#39;@aws-cdk/aws-codecommit\u0026#39;; export class MyappStack extends cdk.Stack { private codeRepository: codecommit.Repository; constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); this.createCodeCommitRepository(); } createCodeCommitRepository() { this.codeRepository = new codecommit.Repository(this, \u0026#39;CodeRepository\u0026#39;, { repositoryName: \u0026#39;MyRepository\u0026#39; }); } } STEP 3 Deploy the CDK application. Execute command below.\ncdk deploy To check our newly created repository, open AWS CodeCommit console.\nIf you open the created repository, you will see that the repository is still empty.\nCommitting Code to AWS CodeCommit Repository. Here you will commit our code to the newly created repository.\nSTEP 1 To add the repository as remote repository, execute command below.\ngit remote add origin codecommit://MyRepository STEP 2 To add current code, execute command below.\ngit add . git commit -m \u0026#34;Add codecommit repository.\u0026#34; STEP 3 To push the committed code to the repository, execute command below.\ngit push origin master If you reopen the repository again in the console, you will see the committed code is now stored in the repository.\nClick the orange arrow on the right hand side to continue to next step.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/3-cleaning-up/2-deleting-cloud9-environment.html",
	"title": "2. Deleting Cloud9 Environment",
	"tags": [],
	"description": "",
	"content": "In this part you will delete the AWS Cloud9 environment you created.\nSTEP 1 Open the Cloud9 console.\nSTEP 2 Choose the Cloud9 IDE that you created.\nSTEP 3 Click DELETE\nSTEP 4 When prompt on confirmation, type \u0026ldquo;Delete\u0026rdquo; and click button Delete to proceed.\nNow you have clean up your resources and finished all the workshop.\nDon\u0026rsquo;t forget to send feedback for future improvements! See you on the next workshop!\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/1-setting-up-environment/2-environment-check-and-setup.html",
	"title": "2. Environment Check and Set Up",
	"tags": [],
	"description": "",
	"content": "Now you are going to check your environment to make sure you can use it to do the worksho.\nCheck NPM version You are going to need Node Package Manager to install CDK construct libraries in our project.\nTo check NPM version execute command below in the terminal.\nnpm --version The output should look a bit similar to this.\n6.14.6 Check and Update CDK Now you need to make sure CDK is installed in our environment and update it to latest version.\nTo check CDK version execute command below in the terminal.\ncdk --version The output should look like this.\n1.70.0 (build c145314) To update the CDK version to latest, execute command below in the terminal.\nnpm i -g -f aws-cdk@latest Installing Git helper for CodeCommit To commit code to AWS CodeCommit using AWS credentials you are going to need to have Git helper for CodeCommit installed in our environment.\nCheck whether PIP is already installed in the system, execute command below.\npip --version The output should look a bit simlar to below.\npip 9.0.3 from /usr/lib/python3.6/dist-packages (python 3.6) To install the git helper for CodeCommit, execute command below.\nsudo pip install git-remote-codecommit Now your environment is ready for the workshop. Click the orange arrow on the right hand side to continue to next step.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/3-cleaning-up.html",
	"title": "Cleaning Up",
	"tags": [],
	"description": "",
	"content": "Chapter 3 Cleaning Up In this part you will clean up the provisioned resources to avoid getting unnecessary cost charged to your AWS account.\nNOTE Another warning: Failure to clean up will cause additional cost incurring to your AWS account.\nClick the orange arrow on the right hand side to continue.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/2-workshop/3-creating-ecs-cluster.html",
	"title": "3. Creating ECS Cluster",
	"tags": [],
	"description": "",
	"content": "In this part, you are going to deploy a simple \u0026ldquo;Hello World\u0026rdquo; application to ECS cluster. Amazon ECS is a fully managed container orchestration service.\nSTEP 1 You are going to need ECS construct library and ECS Patterns L3 constructs library. ECS Patterns library provides higher-level Amazon ECS constructs which follow common architectural patterns.\nExecute command below.\nnpm i @aws-cdk/aws-ecs @aws-cdk/aws-ecs-patterns STEP 2 Add Dockerfile in the project root. This will define our container that serves a \u0026ldquo;Hello World\u0026rdquo; HTML file. The file will contain definition below.\n########## Simple Dockerfile for running HTML file.# To run execute# docker build -t webserver .# docker run -it --rm -d -p 8080:80 --name web webserver#########FROMnginx:latestCOPY ./src/index.html /usr/share/nginx/html/index.htmlSTEP 3 Create a new directory src in the project directory and create new file index.html in that new directory. The HTML file should contain text below.\n\u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; STEP 4 Now create a new file .dockerignore in the project root directory. You need this to prevent unnecessary files to be compiled in our docker container image to keep the image small. The file should look like below.\ncdk.out node_modules STEP 5 Overwrite file lib/myapp-stack.ts with this.\nimport * as cdk from \u0026#39;@aws-cdk/core\u0026#39;; import * as codecommit from \u0026#39;@aws-cdk/aws-codecommit\u0026#39;; import * as ecs from \u0026#39;@aws-cdk/aws-ecs\u0026#39;; import * as ecsPatterns from \u0026#39;@aws-cdk/aws-ecs-patterns\u0026#39;; export class MyappStack extends cdk.Stack { private codeRepository: codecommit.Repository; private cluster: ecs.Cluster; private service: ecs.IService; constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); this.createCodeCommitRepository(); this.createECSApplication(); } createCodeCommitRepository() { this.codeRepository = new codecommit.Repository(this, \u0026#39;CodeRepository\u0026#39;, { repositoryName: \u0026#39;MyRepository\u0026#39; }); } createECSApplication() { this.cluster = new ecs.Cluster(this, \u0026#39;Cluster\u0026#39;); const fargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, \u0026#39;Service\u0026#39;, { cluster: this.cluster, memoryLimitMiB: 1024, cpu: 512, taskImageOptions: { image: ecs.ContainerImage.fromAsset(\u0026#39;.\u0026#39;), containerName: \u0026#39;web\u0026#39;, }, }); this.service = fargateService.service; } } STEP 6 Now to deploy the application, execute command below.\ncdk deploy In this step, the CDK will show a list of permissions change to approve. Input Y to approve and continue.\nPlease wait for a while for CDK to complete the command. By the end of the command, you will see output a bit similar to below.\nThe ServiceServiceURL will contain the URL where you can check the application.\nOpen the URL to check the application.\nTo see the created ECS cluster, open the ECS console and see you have new ECS cluster.\nClick the orange arrow on the right hand side to continue to next step.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/2-workshop/4-creating-ecr-repository.html",
	"title": "4. Creating ECR Container Image Repository",
	"tags": [],
	"description": "",
	"content": "In this part you will create an ECR container image repository. Amazon Elastic Container Registry (ECR) is a fully-managed Docker container registry that makes it easy for developers to store, manage, and deploy Docker container images. Amazon ECR is integrated with Amazon Elastic Container Service (ECS), simplifying your development to production workflow.\nSTEP 1 You are going to need to install ECR construct library. Execute the following command.\nnpm i @aws-cdk/aws-ecr STEP 2 Overwrite file lib/myapp-stack.ts with the code below.\nimport * as cdk from \u0026#39;@aws-cdk/core\u0026#39;; import * as codecommit from \u0026#39;@aws-cdk/aws-codecommit\u0026#39;; import * as ecs from \u0026#39;@aws-cdk/aws-ecs\u0026#39;; import * as ecsPatterns from \u0026#39;@aws-cdk/aws-ecs-patterns\u0026#39;; import * as ecr from \u0026#39;@aws-cdk/aws-ecr\u0026#39;; export class MyappStack extends cdk.Stack { private codeRepository: codecommit.Repository; private cluster: ecs.Cluster; private service: ecs.BaseService; private imageRepository: ecr.Repository; constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); this.createCodeCommitRepository(); this.createECSApplication(); this.createECRRepository(); } createCodeCommitRepository() { this.codeRepository = new codecommit.Repository(this, \u0026#39;CodeRepository\u0026#39;, { repositoryName: \u0026#39;MyRepository\u0026#39; }); } createECSApplication() { this.cluster = new ecs.Cluster(this, \u0026#39;Cluster\u0026#39;); const fargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, \u0026#39;Service\u0026#39;, { cluster: this.cluster, memoryLimitMiB: 1024, cpu: 512, taskImageOptions: { image: ecs.ContainerImage.fromAsset(\u0026#39;.\u0026#39;), containerName: \u0026#39;web\u0026#39;, }, }); this.service = fargateService.service; } createECRRepository() { this.imageRepository = new ecr.Repository(this, \u0026#39;ImageRepository\u0026#39;); new cdk.CfnOutput(this, \u0026#39;ImageRepositoryURI\u0026#39;, { value: this.imageRepository.repositoryUri }); } } STEP 3 To apply the changes, execute the command below.\ncdk deploy When the deploy finished, you will see the URL of the new ECR repository in the output.\nTo see the created ECR repository, visit the ECR console. You will see a new repository created.\nIf you click on the new repository, you will see that there is no image stored yet.\nPushing New Image to ECR Repository Now you are going to try pushing a new image to the ECR repository.\nClick on the View push commands, you will see steps and commands to execute to build local image and push it to the ECR repository.\nThe execution will look like something below.\nTry refreshing the new ECR repository in the ECR console. Now you will see that you have a new image created.\nClick the orange arrow on the right hand side to continue to next step.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/2-workshop/5-creating-build-pipeline.html",
	"title": "5. Creating Build Pipeline",
	"tags": [],
	"description": "",
	"content": "In this step, you are going to create a CI/CD pipeline where you will build a container image on new commit and store the image in our new ECR repository.\nAWS CodePipeline is a fully managed continuous delivery service that helps you automate your release pipelines for fast and reliable application and infrastructure updates. CodePipeline automates the build, test, and deploy phases of your release process every time there is a code change, based on the release model you define. AWS CodeBuild is a fully managed continuous integration service that compiles source code, runs tests, and produces software packages that are ready to deploy. With CodeBuild, you don’t need to provision, manage, and scale your own build servers.\nSTEP 1 You are going to need to install CodePipeline and CodeBuild construct libraries. Execute command below.\nnpm i @aws-cdk/aws-codebuild @aws-cdk/aws-codepipeline @aws-cdk/aws-codepipeline-actions STEP 2 Create file buildspec.yml in the root directory of the application. This file will serve as build definition that we are\nversion: \u0026#39;0.2\u0026#39; phases: pre_build: commands: - aws --version - $(aws ecr get-login --region ${AWS_DEFAULT_REGION} --no-include-email | sed \u0026#39;s|https://||\u0026#39;) - COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-7) - IMAGE_TAG=${COMMIT_HASH:=latest} build: commands: - docker build -t $REPOSITORY_URI:latest . - docker tag $REPOSITORY_URI:latest $REPOSITORY_URI:$IMAGE_TAG post_build: commands: - docker push $REPOSITORY_URI:latest - docker push $REPOSITORY_URI:$IMAGE_TAG - printf \u0026#34;[{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;${CONTAINER_NAME}\\\u0026#34;,\\\u0026#34;imageUri\\\u0026#34;:\\\u0026#34;${REPOSITORY_URI}:latest\\\u0026#34;}]\u0026#34; \u0026gt; imagedefinitions.json artifacts: files: - imagedefinitions.json STEP 3 Overwrite file lib/myapp-stack.ts with this.\nimport * as cdk from \u0026#39;@aws-cdk/core\u0026#39;; import * as codecommit from \u0026#39;@aws-cdk/aws-codecommit\u0026#39;; import * as ecs from \u0026#39;@aws-cdk/aws-ecs\u0026#39;; import * as ecsPatterns from \u0026#39;@aws-cdk/aws-ecs-patterns\u0026#39;; import * as ecr from \u0026#39;@aws-cdk/aws-ecr\u0026#39;; import * as codebuild from \u0026#39;@aws-cdk/aws-codebuild\u0026#39;; import * as codepipeline from \u0026#39;@aws-cdk/aws-codepipeline\u0026#39;; import * as codepipelineActions from \u0026#39;@aws-cdk/aws-codepipeline-actions\u0026#39;; export class MyappStack extends cdk.Stack { private codeRepository: codecommit.Repository; private cluster: ecs.Cluster; private service: ecs.BaseService; private imageRepository: ecr.Repository; constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); this.createCodeCommitRepository(); this.createECSApplication(); this.createECRRepository(); this.createPipeline(); } createCodeCommitRepository() { this.codeRepository = new codecommit.Repository(this, \u0026#39;CodeRepository\u0026#39;, { repositoryName: \u0026#39;MyRepository\u0026#39; }); } createECSApplication() { this.cluster = new ecs.Cluster(this, \u0026#39;Cluster\u0026#39;); const fargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, \u0026#39;Service\u0026#39;, { cluster: this.cluster, memoryLimitMiB: 1024, cpu: 512, taskImageOptions: { image: ecs.ContainerImage.fromAsset(\u0026#39;.\u0026#39;), containerName: \u0026#39;web\u0026#39;, }, }); this.service = fargateService.service; } createECRRepository() { this.imageRepository = new ecr.Repository(this, \u0026#39;ImageRepository\u0026#39;); new cdk.CfnOutput(this, \u0026#39;ImageRepositoryURI\u0026#39;, { value: this.imageRepository.repositoryUri }); } createPipeline() { const pipeline = new codepipeline.Pipeline(this, \u0026#39;Pipeline\u0026#39;, { stages: this.createPipelineStages(), }); } createPipelineStages() { const sourceOutput = new codepipeline.Artifact(); const buildOutput = new codepipeline.Artifact(); return [ this.createStageSource(sourceOutput), this.createStageBuild(sourceOutput, buildOutput), ]; } createStageSource(output: codepipeline.Artifact): codepipeline.StageOptions { const action = new codepipelineActions.CodeCommitSourceAction({ actionName: \u0026#39;CodeCommit\u0026#39;, repository: this.codeRepository, output: output, }); return { stageName: \u0026#39;Source\u0026#39;, actions: [ action ] }; } createStageBuild(input: codepipeline.Artifact, output: codepipeline.Artifact): codepipeline.StageOptions { const project = new codebuild.PipelineProject(this, \u0026#39;ImageBuildProject\u0026#39;, { environment: { buildImage: codebuild.LinuxBuildImage.STANDARD_2_0, privileged: true, }, buildSpec: codebuild.BuildSpec.fromSourceFilename(\u0026#39;buildspec.yml\u0026#39;), environmentVariables: { REPOSITORY_URI: {value: this.imageRepository.repositoryUri}, CONTAINER_NAME: {value: \u0026#34;web\u0026#34;}, } }); this.imageRepository.grantPullPush(project.grantPrincipal); const action = new codepipelineActions.CodeBuildAction({ actionName: \u0026#39;ImageBuildAction\u0026#39;, input: input, outputs: [output], project: project, }); return { stageName: \u0026#39;Build\u0026#39;, actions: [ action ] }; } } STEP 4 Execute following line to apply the change.\ncdk deploy Input y on the prompt.\nTo see the newly created pipeline, open the CodePipeline console. You will see you have a new pipeline.\nOpen the new pipeline, you will have 2 stages: Source and Build\nYou now may see the Build process fails. In the next part you will push the code that will trigger a success build.\nCommitting Code to Trigger Build Now you are going to trigger the build process by committing a new code.\nSTEP 1 Since you haven\u0026rsquo;t committed any new code yet, now it\u0026rsquo;s time to push the changes to git.\ngit add . git commit -m \u0026#34;Add build pipeline.\u0026#34; git push origin master Open the pipeline again in the CodePipeline console. You will see that a build process now is in progress.\nYou can click on the Details in the Build stage to monitor the process.\nWhen the build process finishes, open our ECR repository again and you will see a new image has been pushed.\nClick the orange arrow on the right hand side to continue to final part of this workshop.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/2-workshop/6-creating-deploy-pipeline.html",
	"title": "6. Creating Deploy Stage",
	"tags": [],
	"description": "",
	"content": "In this part you are going to create a final stage of the pipeline \u0026ldquo;Deploy\u0026rdquo; where the newly created image will be deployed to the ECS cluster.\nSTEP 1\nimport * as cdk from \u0026#39;@aws-cdk/core\u0026#39;; import * as codecommit from \u0026#39;@aws-cdk/aws-codecommit\u0026#39;; import * as ecs from \u0026#39;@aws-cdk/aws-ecs\u0026#39;; import * as ecsPatterns from \u0026#39;@aws-cdk/aws-ecs-patterns\u0026#39;; import * as ecr from \u0026#39;@aws-cdk/aws-ecr\u0026#39;; import * as codebuild from \u0026#39;@aws-cdk/aws-codebuild\u0026#39;; import * as codepipeline from \u0026#39;@aws-cdk/aws-codepipeline\u0026#39;; import * as codepipelineActions from \u0026#39;@aws-cdk/aws-codepipeline-actions\u0026#39;; export class MyappStack extends cdk.Stack { private codeRepository: codecommit.Repository; private cluster: ecs.Cluster; private service: ecs.BaseService; private imageRepository: ecr.Repository; constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) { super(scope, id, props); this.createCodeCommitRepository(); this.createECSApplication(); this.createECRRepository(); this.createPipeline(); } createCodeCommitRepository() { this.codeRepository = new codecommit.Repository(this, \u0026#39;CodeRepository\u0026#39;, { repositoryName: \u0026#39;MyRepository\u0026#39; }); } createECSApplication() { this.cluster = new ecs.Cluster(this, \u0026#39;Cluster\u0026#39;); const fargateService = new ecsPatterns.ApplicationLoadBalancedFargateService(this, \u0026#39;Service\u0026#39;, { cluster: this.cluster, memoryLimitMiB: 1024, cpu: 512, taskImageOptions: { image: ecs.ContainerImage.fromAsset(\u0026#39;.\u0026#39;), containerName: \u0026#39;web\u0026#39;, }, }); this.service = fargateService.service; } createECRRepository() { this.imageRepository = new ecr.Repository(this, \u0026#39;ImageRepository\u0026#39;); new cdk.CfnOutput(this, \u0026#39;ImageRepositoryURI\u0026#39;, { value: this.imageRepository.repositoryUri }); } createPipeline() { const pipeline = new codepipeline.Pipeline(this, \u0026#39;Pipeline\u0026#39;, { stages: this.createPipelineStages(), }); } createPipelineStages() { const sourceOutput = new codepipeline.Artifact(); const buildOutput = new codepipeline.Artifact(); return [ this.createStageSource(sourceOutput), this.createStageBuild(sourceOutput, buildOutput), this.createStageDeploy(buildOutput) ]; } createStageSource(output: codepipeline.Artifact): codepipeline.StageOptions { const action = new codepipelineActions.CodeCommitSourceAction({ actionName: \u0026#39;CodeCommit\u0026#39;, repository: this.codeRepository, output: output, }); return { stageName: \u0026#39;Source\u0026#39;, actions: [ action ] }; } createStageBuild(input: codepipeline.Artifact, output: codepipeline.Artifact): codepipeline.StageOptions { const project = new codebuild.PipelineProject(this, \u0026#39;ImageBuildProject\u0026#39;, { environment: { buildImage: codebuild.LinuxBuildImage.STANDARD_2_0, privileged: true, }, buildSpec: codebuild.BuildSpec.fromSourceFilename(\u0026#39;buildspec.yml\u0026#39;), environmentVariables: { REPOSITORY_URI: {value: this.imageRepository.repositoryUri}, CONTAINER_NAME: {value: \u0026#34;web\u0026#34;}, } }); this.imageRepository.grantPullPush(project.grantPrincipal); const action = new codepipelineActions.CodeBuildAction({ actionName: \u0026#39;ImageBuildAction\u0026#39;, input: input, outputs: [output], project: project, }); return { stageName: \u0026#39;Build\u0026#39;, actions: [ action ] }; } createStageDeploy(input: codepipeline.Artifact): codepipeline.StageOptions { this.imageRepository.grantPull(this.service.taskDefinition.executionRole!); const action = new codepipelineActions.EcsDeployAction({ actionName: \u0026#39;ProductionEcsDeployAction\u0026#39;, input: input, service: this.service, }); return { stageName: \u0026#39;DeployToProduction\u0026#39;, actions: [ action ], }; } } STEP 2 To apply the change, execute the command below.\ncdk deploy Input y on the prompt.\nWhen the progess finishes, check the pipeline again and you will see that now you have one additional stage \u0026ldquo;DeployToProduction\u0026rdquo;.\nNext you will commit a code to deploy to the Amazon ECS cluster.\nCommitting Code to Trigger Deploy Try editing the src/index.html to new value.\n\u0026lt;h1\u0026gt;Hello all!\u0026lt;/h1\u0026gt; Now we commit and push the change\ngit add . git commit -m \u0026quot;add deploy.\u0026quot; git push origin master Open the pipeline again and you will see the build started.\nYou wait for few minutes for the deploy to finish. When the pipeline finish, open the load balancer URL.\nYou will see the new HTML code deployed. If it hasn\u0026rsquo;t yet, wait for few more minutes, it takes some time for the cluster to deploy.\nCongratulations, you now have successfully build a new CI/CD Pipeline using AWS CDK!\nClick the orange arrow on the right hand side to continue to clean up all the resources.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "AWS Workshop Building CI/CD Pipeline using AWS CDK Welcome to Modern Application Workshop: Building CI/CD Pipeline using AWS Cloud Development Kit.\nIn this workshop you will learn how to orchestrate AWS CI/CD tools such as AWS CodePipeline, AWS CodeBuild, and AWS CodeCommit by using Infrastructure as Code with AWS Cloud Development Kit. This workshop should take you 60-70 minutes to accomplish.\nClick the orange arrow in the right hand side to start your journey.\n"
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://petrabarus.github.io/aws-cicd-cdk-workshop/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]